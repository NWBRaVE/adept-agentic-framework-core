# values.yaml
# Default values for agentic-framework.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- The namespace where all Kubernetes resources will be deployed.
namespace: class # <--- Added for EMSL's rzr: Explicitly set the target namespace for the Helm release.

replicaCount: 1

nameOverride: ""
fullnameOverride: ""

# -- Global values that can be inherited by all services
global:
  image:
    pullPolicy: Always # Use 'Never' for local dev, 'Always' for production; switched to Always for rzr/emsl deployments
    tag: "latest"
  # -- Proxy configuration for outbound HTTP/HTTPS requests
  proxy:
    # -- HTTP proxy server URL (e.g., http://proxy.example.com:8080)
    httpProxy: "http://proxy01.pnl.gov:3128"
    # -- HTTPS proxy server URL (e.g., http://proxy.example.com:8080)
    httpsProxy: "http://proxy01.pnl.gov:3128"
    # -- List of hosts, domains, and IP addresses that should bypass the proxy.
    # The Helm chart will automatically add the internal Kubernetes service names to this list.
    # Suffixes should start with a dot (e.g., .svc, .cluster.local).
    # OLD: noProxy: "localhost,127.0.0.1,pnl.gov,pnnl.gov,*.pnl.gov,*.pnnl.gov,10.17.0.0/16,*agentic-framework*,*.svc,*.cluster.local"
    # NEW: Updated noProxy to include EMSL's rzr cluster and PNNL domains
    noProxy:
      - localhost
      - 127.0.0.1
      - .pnl.gov
      - .pnnl.gov
      - .svc
      - .cluster.local
      - 10.17.0.0/16
      - mcp_server
      - streamlit_app
      - hpc_mcp_server
      - sandbox_mcp_server

# -- Configuration for Kubernetes image pull secrets.
# This secret must be created manually in the target namespace (e.g., 'class').
# Example command:
# kubectl create secret docker-registry ghcr-secret \
#   --docker-server=ghcr.io \
#   --docker-username=<your-username> \
#   --docker-password=<your-password> \
#   --docker-email=<your-email> \
#   --namespace class
imagePullSecrets: # <--- NEW SECTION FOR IMAGE PULL SECRETS
  - name: ghcr-secret # Name of the Kubernetes secret (e.g., 'ghcr-secret')

# -- Secret values for the application.
# It is strongly recommended to manage secrets outside of values.yaml.
# For production, use a pre-existing secret or a tool like External Secrets Operator.
secrets:
  # -- Create a new secret resource. If false, you must provide an existingSecretName.
  create: true
  # -- Name of an existing secret to use.
  existingSecretName: ""
  # -- API keys and other sensitive data. These will be base64 encoded by Helm.
  # Example:
  # OPENAI_API_KEY: "sk-..."
  # AZURE_API_KEY: "..."
  data: {}

# -- Configuration for the main MCP server
mcp_server:
  enabled: true
  image:
    repository: ghcr.io/pnnl/adept-agentic-framework-core/mcp_server # <--- UPDATED REPOSITORY
  service:
    type: ClusterIP
    port: 8080

# -- Configuration for the Streamlit UI application
streamlit_app:
  enabled: true
  image:
    repository: ghcr.io/pnnl/adept-agentic-framework-core/streamlit_app # <--- UPDATED REPOSITORY
  service:
    type: ClusterIP
    port: 8501

# -- Configuration for the HPC MCP server
hpc_mcp_server:
  enabled: true
  image:
    repository: ghcr.io/pnnl/adept-agentic-framework-core/hpc_mcp_server # <--- UPDATED REPOSITORY
  service:
    type: ClusterIP
    port: 8081

# -- Configuration for the Sandbox MCP server
sandbox_mcp_server:
  enabled: true
  image:
    repository: ghcr.io/pnnl/adept-agentic-framework-core/sandbox_mcp_server # <--- UPDATED REPOSITORY
  service:
    type: ClusterIP
    port: 8082
  # -- Backend for code execution. Options: "kubernetes" or "docker".
  # "kubernetes": Executes code in ephemeral pods. Requires RBAC permissions. More secure for clusters.
  # "docker": Uses Docker-out-of-Docker. Requires privileged mode and mounting the host's docker socket. Simpler for local dev.
  backend: "kubernetes" # <-- SET THIS TO "docker" FOR YOUR LOCAL DOCKER DESKTOP SETUP

  # -- Settings for the 'docker' backend. These are ignored if backend is 'kubernetes'.
  dockerBackend:
    # -- CRITICAL: Required for llm-sandbox (nsjail) to function with the docker backend.
    # This grants the container extended privileges on the host machine.
    # Understand the security implications before enabling this in production.
    privileged: true
    # -- Path to the Docker socket on the host machine.
    socketPath: "/var/run/docker.sock"

# -- Ingress configuration for exposing the Streamlit UI
ingress:
  enabled: true
  className: "pnnl" # 
  annotations: 
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # For AWS ALB Ingress Controller:
    # alb.ingress.kubernetes.io/scheme: internet-facing
    # alb.ingress.kubernetes.io/target-type: ip
    nginx.ingress.kubernetes.io/proxy-body-size: "100m" # Increase body size limit for file uploads
    nginx.ingress.kubernetes.io/proxy-read-timeout: "300" # Increase read timeout for long-running requests
  hosts:
    - host: agentic.emsl.pnl.gov #chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: 
   - secretName: default-tls
     hosts:
       - agentic.emsl.pnl.gov

# -- Persistence configuration using PersistentVolumeClaims
persistence:
  # -- Shared data volume for SQLite, ChromaDB, etc.
  data:
    enabled: true
    # -- For AWS EKS, use a StorageClass like 'efs-sc' that supports ReadWriteMany.
    # For local dev, this can be omitted to use the default provisioner.
    storageClassName: "mscmsc-nfs"
    accessMode: ReadWriteOnce
    size: 5Gi
  # -- Shared volume for file uploads between services
  shared_uploads:
    enabled: true
    storageClassName: "mscmsc-nfs"
    accessMode: ReadWriteOnce
    size: 5Gi # 10Gi
  # -- Volume for BLAST databases for the HPC server
  blast_databases:
    enabled: true
    # -- Use a ReadWriteMany StorageClass if multiple HPC pods might run.
    # For a single pod, ReadWriteOnce is sufficient.
    storageClassName: "mscmsc-nfs"
    accessMode: ReadWriteOnce
    size: 5Gi #50Gi

# -- Resource requests and limits for the containers
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts will run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

nodeSelector: {}

tolerations: []

affinity: {}
